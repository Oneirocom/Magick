# Transition XState Machines in Magick Applications Based on Given State Variables 

## Metadata

- **Status**: accepted 
- **Deciders**: Magick, fire, benbot
- **Tags**: Magick, xstate, transition, state

## Context and Problem Statement

In our ongoing development of an application using `XState` and `Magick`, we are facing a challenge with transitioning between states of the machine based on specific variables. Achieving a consistent way to manage these transitions is crucial.

## Proposed Solution

The creation of a Magick plugin that can receive the current state and an event as inputs and give back the next state according to the established transitions will offer a viable solution.

## Implementation

Below is the pseudocode mocking this solution with a rete1 node:

```typescript
class TransitionNode extends Rete.Component {
    constructor(){
        super("TransitionNode");
        this.data.component = Node;
    }

    builder(node) {
        var triggerInput = new Rete.Input('trigger', 'Trigger Input', triggerSocket);
        var stateInput = new Rete.Input('state', "State Input", objSocket);
        var stateMachineInput = new Rete.Input('stateMachine',"State Machine Input", objSocket);
        var newStateInput = new Rete.Input('newState',"New State Input", objSocket);
        var triggerOutput = new Rete.Output('newTrigger', 'New Trigger Output', triggerSocket);
        var stateTransitionOutput = new Rete.Output('next', "Next State Output", strSocket);
        var stateOutput = new Rete.Output('newState', "New State Output", objSocket);

        return node.addInput(triggerInput).addInput(stateInput).addInput(stateMachineInput).addInput(newStateInput).addOutput(triggerOutput).addOutput(stateTransitionOutput).addOutput(stateOutput);
    }
    worker(node, inputs, outputs) {
        var trigger = inputs['trigger'].length ? inputs['trigger'][0] : null;
        var state = inputs['state'].length ? inputs['state'][0] : null;
        var stateMachine = inputs['stateMachine'].length ? inputs['stateMachine'][0] : null;
        var newState = inputs['newState'].length ? inputs['newState'][0] : null;

        // If 'state' is empty, use 'stateMachine'
        var selectedState = state ? state : stateMachine;

        var resultState = computeNewState(selectedState, newState);

        outputs['newTrigger'] = trigger;
        outputs['next'] = resultState;
        outputs['newState'] = newState;
    }
}
```

### User story requirements

Upon implementation, a user would be able to:

1. Define states of the state machine using one JSON string. This string can easily be converted to an object for processing and back to a string for storage or transmission.
2. Define the state machine using a JSON string. This string can easily be converted to an object for processing and back to a string for storage or transmission.
3. Trigger a state machine transition, the current state should change in accordance to the transition rule defined in its state machine given the string of the state transition.

## Positive Consequences

- Brings consistency in managing state transitions.
- Reduces complexity inherent in manually handling state transitions.

## Negative Consequences

- Calls for meticulous planning and designing of state machines.
- Possible surge in complexity if state machines get too large or twisted.

## Option graveyard

An initial proposal was to manually manage state changes within each component. Such a method got discarded due to its high potential for generating inconsistent behavior across components and scalability issues ensuing as the project expands.

## If this enhancement will be used infrequently, can it be worked around with a few nodes?

This feature mirrors core attributes of the application's state management and cannot be effectively bypassed with ad-hoc solutions.

## Is there a reason why this should be core and done by us?

Effective state management is essential for maintaining the robustness and reliability of the application. Therefore, it should be treated as a core feature, designed and implemented by ourselves.

## References

- [XState Documentation](https://xstate.js.org/docs/)